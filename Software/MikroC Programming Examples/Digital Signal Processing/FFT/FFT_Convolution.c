/*
 * Project name:
     FFT_Convolution (FFT library test example)
 * Description:
      The convolution theorem states that convolution in the time domain corresponds to multiplication in
      the frequency domain. Therefore, the Fourier transform of the convoution of two signals is equal to
      the product of their individual Fourier transforms. The Fourier transform of a signal can be evaluated
      efficiently using the Fast Fourier Transform (FFT).

      Two input signals, a[n] and b[n], with lengths n1 and n2 respectively, are zero padded so that their
      lengths become N, which is greater than or equal to (n1+n2-1) and is a power of 4 as FFT implementation
      is radix-4.

      The convolution of a[n] and b[n] is obtained by taking the FFT of the input signals, multiplying the
      FFT of the two signals, and taking the inverse FFT of the multiplied result.

      This is denoted by the following equations:
      A[k] = FFT(a[n],N)
      B[k] = FFT(b[n],N)
      conv(a[n], b[n]) = IFFT(A[k] * B[k], N)
      where A[k] and B[k] are the N-point FFTs of the signals a[n] and b[n] respectively.
      The length of the convolved signal is (n1+n2-1).
      
 * Test configuration:
     MCU:             STM32F107VC
                      http://www.st.com/st-web-ui/static/active/en/resource/technical/document/reference_manual/CD00171190.pdf
     dev.board:       EasyMx v7 for STM32 ® ARM ®
                      http://www.mikroe.com/easymx-pro/stm32/
     Oscillator:      HSE-PLL, 72.000MHz
     Ext. Modules:    None.
     SW:              mikroC PRO for ARM
                      http://www.mikroe.com/mikroc/arm/
 * NOTES:
     - None.
*/

#include "stdint.h"
#include "__Dsp.h"

#define FFT_BLOCKSIZE 128
#define SNR_THRESHOLD 30
 
// Declare I/O buffers
// -------------------------------------------------------------------
q15_t     testInputA_q15[FFT_BLOCKSIZE/2];
q15_t     testInputB_q15[FFT_BLOCKSIZE/2];
q15_t     Ak[FFT_BLOCKSIZE];             // q15 input A
q15_t     Bk[FFT_BLOCKSIZE];             // q15 input B
q15_t     AxB_q15[FFT_BLOCKSIZE];        // q15 output
float32_t AxB_f32[FFT_BLOCKSIZE];        // f32 output
int cnt;
 
// Test input data for Floating point Convolution example 
// for 32-blockSize generated by the MATLAB randn() function
// -------------------------------------------------------------------
const float32_t testInputA_f32[64] = {
-0.808920,  1.357369,  1.180861, -0.504544,  1.762637, -0.703285,
 1.696966,  0.620571, -0.151093, -0.100235, -0.872382, -0.403579,
-0.860749, -0.382648, -1.052338,  0.128113, -0.646269,  1.093377,
-2.209198,  0.471706,  0.408901,  1.266242,  0.598252,  1.176827,
-0.203421,  0.213596, -0.851964, -0.466958,  0.021841, -0.698938,
-0.604107,  0.461778, -0.318219,  0.942520,  0.577585,  0.417619,
 0.614665,  0.563679, -1.295073, -0.764437,  0.952194, -0.859222,
-0.618554, -2.268542, -1.210592,  1.655853, -2.627219, -0.994249,
-1.374704,  0.343799,  0.025619,  1.227481, -0.708031,  0.069355,
-1.845228, -1.570886,  1.010668, -1.802084,  1.630088,  1.286090,
-0.161050, -0.940794,  0.367961,  0.291907
};
  
const float32_t testInputB_f32[64] = {
 0.933724,  0.046881,  1.316470,  0.438345,  0.332682,  2.094885,
 0.512081,  0.035546,  0.050894, -2.320371,  0.168711, -1.830493,
-0.444834, -1.003242, -0.531494, -1.365600, -0.155420, -0.757692,
-0.431880, -0.380021,  0.096243, -0.695835,  0.558850, -1.648962,
 0.020369, -0.363630,  0.887146,  0.845503, -0.252864, -0.330397,
 1.269131, -1.109295, -1.027876,  0.135940,  0.116721, -0.293399,
-1.349799,  0.166078, -0.802201,  0.369367, -0.964568, -2.266011,
 0.465178,  0.651222, -0.325426,  0.320245, -0.784178, -0.579456,
 0.093374,  0.604778, -0.048225,  0.376297, -0.394412,  0.578182,
-1.218141, -1.387326,  0.692462, -0.631297,  0.153137, -0.638952,
 0.635474, -0.970468,  1.334057, -0.111370
};  
  
const float testRefOutput_f32[126] = {
 -0.818943,  1.229484,  -0.533664,   1.016604,  0.341875, -1.963656,
  5.171476,  3.478033,   7.616361,   6.648384,  0.479069,  1.792012,
 -1.295591, -7.447818,   0.315830, -10.657445, -2.483469, -6.524236,
 -7.380591, -3.739005,  -8.388957,   0.184147, -1.554888,  3.786508,
 -1.684421,  5.400610,  -1.578126,   7.403361,  8.315999,  2.080267,
 11.077776,  2.749673,   7.138962,   2.748762,  0.660363,  0.981552,
  1.442275,  0.552721,  -2.576892,   4.703989,  0.989156,  8.759344,
 -0.564825, -3.994680,   0.954710,  -5.014144,  6.592329,  1.599488,
-13.979146, -0.391891,  -4.453369,  -2.311242, -2.948764,  1.761415,
-0.138322,  10.433007,  -2.309103,   4.297153,  8.535523,  3.209462,
 8.695819,   5.569919,   2.514304,   5.582029,  2.060199,  0.642280,
 7.024616,   1.686615,  -6.481756,   1.343084, -3.526451,  1.099073,
-2.965764,  -0.173723,  -4.111484,   6.528384, -6.965658,  1.726291,
 1.535172,  11.023435,   2.338401,  -4.690188,  1.298210,  3.943885,
 8.407885,   5.168365,   0.684131,   1.559181,  1.859998,  2.852417,
 8.574070,  -6.369078,   6.023458,  11.837963, -6.027632,  4.469678,
-6.799093,  -2.674048,   6.250367,  -6.809971, -3.459360,  9.112410,
-2.711621,  -1.336678,   1.564249,  -1.564297, -1.296760,  8.904013,
-3.230109,   6.878013,  -7.819823,   3.369909, -1.657410, -2.007358,
-4.112825,   1.370685,  -3.420525,  -6.276605,  3.244873, -3.352638,
 1.545372,   0.902211,   0.197489,  -1.408732,  0.523390,  0.348440
}; 
 
uint32_t srcALen = 64;         // Length of Input A
uint32_t srcBLen = 64;         // Length of Input B
uint32_t outLen;               // Length of convolution output
float32_t snr;                 // output SNR

const char TEST_FAILURE = 1;
const char TEST_SUCCESS = 0;

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#define FACTOR 7
void ComplexMult_Q15(q15_t *pSrcA, q15_t *pSrcB, q15_t *pDst, uint32_t numSamples) {
  q15_t a, b, c, d;
  uint32_t blkCnt;

  blkCnt = numSamples;

  while(blkCnt > 0) {

    // C[2 * i] = A[2 * i] * B[2 * i] - A[2 * i + 1] * B[2 * i + 1]
    // C[2 * i + 1] = A[2 * i] * B[2 * i + 1] + A[2 * i + 1] * B[2 * i]
    a = *pSrcA++;
    b = *pSrcA++;
    c = *pSrcB++;
    d = *pSrcB++;

    // Store results in the destination buffer
    *pDst++ = (q15_t) ((((q31_t) a * c) - ((q31_t) b * d)) >> FACTOR);
    *pDst++ = (q15_t) ((((q31_t) a * d) + ((q31_t) b * c)) >> FACTOR);

    blkCnt--;
  }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------
// Calculation of SNR.
// Parameters:
//  *pRef         pointer to the reference buffer
//  *pTest        pointer to the test buffer
//   buffSize     total number of samples
// Returns:       SNR
// --------------------------------------------------------------------

float SNRCalc(float *pRef, float *pTest, uint32_t buffSize) {
  float EnergySignal = 0, EnergyError = 0;
  uint32_t i;
  float SNR;
  int temp;
  int *test;

  for (i = 0; i < buffSize; i++) {
    // Checking for a NAN value in pRef array
    test = (int *)(&pRef[i]);
    temp = *test;
    if(temp == 0x7FC00000) {
      return(0);
    }

    // Checking for a NAN value in pTest array
    test = (int *)(&pTest[i]);
    temp =  *test;
    if(temp == 0x7FC00000) {
      return(0);
    }
    EnergySignal += pRef[i] * pRef[i];
    EnergyError += (pRef[i] - pTest[i]) * (pRef[i] - pTest[i]);
  }

  // Checking for a NAN value in EnergyError
  test = (int *)(&EnergyError);
  temp = *test;
  if(temp == 0x7FC00000) {
    return(0);
  }
  SNR = 10 * log10 (EnergySignal / EnergyError);
  return (SNR);
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

void main() {
  char status;
  TFFT_Radix4_Instance cfft_instance;
  TFFT_Radix4_Instance *cfft_instance_ptr = (TFFT_Radix4_Instance*) &cfft_instance;
 
  // Set LED indicators
  GPIO_Digital_Output(&GPIOA_BASE, _GPIO_PINMASK_0 | _GPIO_PINMASK_4); // Set PORTA.0 and PORTA.4  as digital output
  GPIOA_ODR.B0 = 0;
  GPIOA_ODR.B4 = 0;

  // Output length of convolution
  outLen = srcALen + srcBLen - 1;

  // Convert input data from float to q15
  for(cnt = 0; cnt < 64; cnt++) {
    testInputA_q15[cnt] = Q15_Ftoi(testInputA_f32[cnt]/4);
    testInputB_q15[cnt] = Q15_Ftoi(testInputB_f32[cnt]/4);
  }

  // Initialize the FFT input buffers with all zeros
  Vector_Set16(Ak, FFT_BLOCKSIZE, 0);
  Vector_Set16(Bk, FFT_BLOCKSIZE, 0);

  // Copy the input values to the FFT input buffers */
  memcpy(Ak, testInputA_q15, FFT_BLOCKSIZE);
  memcpy(Bk, testInputB_q15, FFT_BLOCKSIZE);
  
  // Initialize the CFFT function to compute 64 point FFT
  status = FFT_Radix4_Init(cfft_instance_ptr, 64, 0, 1);
 
  // Transform input a[n] from time domain to frequency domain A[k]
  FFT_Radix4(cfft_instance_ptr, Ak);
  
  // Transform input b[n] from time domain to frequency domain B[k]
  FFT_Radix4(cfft_instance_ptr, Bk);

  // Complex Multiplication of the two input buffers in frequency domain
  ComplexMult_Q15(Ak, Bk, AxB_q15, FFT_BLOCKSIZE/2);
  
  // Initialize the CIFFT function to compute 64 point IFFT
  status = FFT_Radix4_Init(cfft_instance_ptr, 64, 1, 1);
 
  // Transform the multiplication output from frequency domain to time domain, that gives the convolved output
  FFT_Radix4(cfft_instance_ptr, AxB_q15);
  
  // Convert q15 result back to float
  for(cnt = 0; cnt < FFT_BLOCKSIZE; cnt++) {
    AxB_f32[cnt] = Q15_Itof(AxB_q15[cnt])*256;
  }

  // Classical CMSIS SNR test
  snr = SNRCalc((float32_t *)testRefOutput_f32, AxB_f32, srcALen + srcBLen - 1);
  if (snr < SNR_THRESHOLD) {
    status = TEST_FAILURE;
  }
  else {
    status = TEST_SUCCESS;
  }

  if( status != TEST_SUCCESS) {
    // Loop here if the signal does not match the reference output.
    GPIOA_ODR.B0 = 0;
    GPIOA_ODR.B4 = 1;
  }
  else {
    // Success
    GPIOA_ODR.B0 = 1;
    GPIOA_ODR.B4 = 1;
  }
}